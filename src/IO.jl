# ==================================================================================================== #
#                                              IO.jl                                                   #
# ---------------------------------------------------------------------------------------------------- #
#   Authors         : Julian Stobbe                                                                    #
# ----------------------------------------- Description ---------------------------------------------- #
#   Read/Write functions.                                                                              #
#   Contains the public interface connection in/out data from different (partiall private) programs    #
# -------------------------------------------- TODO -------------------------------------------------- #
#   Generalize CSV input to allow for arbitrary spin combinations                                      #
#   Serialize transform function in EquivalenceClassesConstructor.                                     #
# ==================================================================================================== #

"""
    expand_2PtGF_CSV(freqFile::String, dataFile::String)

Expands a two particle Green's function object, given in human readable column format,
from a minimal to the full representation.
Symmetries and spin representation are given in [`doi:10.34726/hss.2013.21498`](https://repositum.tuwien.at/handle/20.500.12708/6957)

Input:
======
`freqFile`: The output generated by the script over [`here`](https://github.com/Atomtomate/EquivalenceClassesConstructor.jl/blob/main/VertexReducedGrid.jl).
`data`    : The thre frequency object with 3 colums that include the frequencies, 
            2x2 columns with real and imaginary part of the `up up` and `up down` spin combinations.

Output:
======
`nBose`   : number of bosonic frequencies
`nFermi`  : number of fermionic frequencies
`shift`   : true if fermionic grid is shifted by half of bosonic frequency
`indArr`  : array in the same shape as the output, corresponding to the Matsubara frequency at each index.
`data_uu` : expanded data in the up_up spin channel.
`data_ud` : expanded data in the up_down spin channel.
"""
function expand_2PtGF_CSV(freqFile::String, dataFile::String)
    transform! = transform_template
    jldopen(freqFile, "r") do f
        for k in ["freqList", "freqRed_map", "parents", "ops", "nBose", "nFermi", "shift"]
            s=Symbol(k)
            @eval (($s) = ($(f[k])))
        end
        # transform! = haskey(f, "transform_func") ? f["transform_func"] : transform_template
    end

    freq_red, TwoPartGF_upup_red, TwoPartGF_updo_red = read_two_pt_function(dataFile) 
    TwoPartGF_upup, TwoPartGF_updo = expand_2pt_GF(TwoPartGF_upup_red, TwoPartGF_updo_red, transform!, freqRed_map, freqList, parents, ops, nBose, nFermi);
    return nBose, nFermi, shift, freqList, TwoPartGF_upup, TwoPartGF_updo
end


# -------------------- Auxilliary ----------------------
"""
    transform_f(F_up::Vector, F_do::Vector, prev::Int, next::Int, ops::Vector{Int})

This is a hardcoded fallback for the expansion operations generated
by the reduced grid [`script`](https://github.com/Atomtomate/EquivalenceClassesConstructor.jl).
At the moment I have not implemented proper serialization for the transform function.
"""
function transform_template(F_up::Vector, F_do::Vector, prev::Int, next::Int, ops::Vector{Int})
    if ops[next] == 1 
        F_up[next] = conj(F_up[prev])
        F_do[next] = conj(F_do[prev])
    elseif ops[next] == 3 || ops[next] == 4
        F_up[next] = -F_up[prev]
        F_do[next] = F_do[prev] - F_up[prev]
    else
        F_up[next] = F_up[prev]
        F_do[next] = F_do[prev]
    end
end
